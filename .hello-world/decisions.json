{
  "decisions": [
    {
      "id": "d_a6eabc7b",
      "title": "Use Tauri over Electron",
      "context": "Electron subprocess hangs after 6+ attempts. Need reliable process spawning.",
      "chosen": "Tauri (Rust backend + webview)",
      "alternatives": [
        {
          "option": "Electron",
          "tradeoff": "Subprocess hangs, 150MB+ bundle"
        },
        {
          "option": "VS Code extension",
          "tradeoff": "Limited UX control, plugin not product"
        }
      ],
      "rationale": "Smaller bundle, Rust process spawning is reliable, existing React code ports directly",
      "decidedAt": "2026-02-22T04:00:09.031Z",
      "decidedBy": "both"
    },
    {
      "id": "d_c29246fe",
      "title": "Hybrid stack: Rust I/O + TypeScript domain logic",
      "context": "Need fast I/O (process spawning, file ops) but rapid iteration on domain logic",
      "chosen": "Rust for I/O, TypeScript for brain/state/agents",
      "alternatives": [],
      "rationale": "Best of both worlds â€” reliability where it matters, iteration speed where it matters",
      "decidedAt": "2026-02-22T04:00:09.032Z",
      "decidedBy": "claude"
    },
    {
      "id": "d_02238108",
      "title": "Port Synaptica brain engine as memory layer",
      "context": "Need cross-session project memory. Synaptica already has hippocampal retrieval.",
      "chosen": "Port 9-stage pipeline from Synaptica, adapt to project-scoped memory",
      "alternatives": [],
      "rationale": "Proven architecture, pain/win/fact types, plasticity/decay already battle-tested",
      "decidedAt": "2026-02-22T04:00:09.032Z",
      "decidedBy": "both"
    },
    {
      "id": "d_a4f6022a",
      "title": "JSON file storage, swappable to SQLite",
      "context": "MSVC build tools not available at scaffold time for better-sqlite3",
      "chosen": "JsonStore with same interface, migrate to SQLite when ready",
      "alternatives": [],
      "rationale": "Unblocks development immediately, storage is an implementation detail",
      "decidedAt": "2026-02-22T04:00:09.033Z",
      "decidedBy": "claude"
    },
    {
      "id": "d_bc50e845",
      "title": "Remove max-w-3xl width constraint from all views",
      "context": "All list views (Memory, Decisions, Questions, Sessions, Cost) had max-w-3xl on their content containers, leaving dead horizontal space on wider screens.",
      "chosen": "Remove max-w-3xl, let cards span full width",
      "alternatives": [
        {
          "option": "Keep max-w-3xl",
          "tradeoff": "Consistent reading width but wastes screen space"
        },
        {
          "option": "Center with max-w-3xl",
          "tradeoff": "Looks better than left-aligned but adds complexity"
        }
      ],
      "rationale": "Cards filling the full width looks better and uses the available space. No content benefit to constraining width in a desktop app.",
      "decidedAt": "2026-02-22T07:39:03.670Z",
      "decidedBy": "both"
    },
    {
      "id": "d_ea09d5af",
      "title": "Keep deliberations practical and actionable",
      "context": "Pat observed that meta-philosophical topics like 'is this system valuable' cause agents to spiral into unfalsifiable positions",
      "chosen": "Only run deliberations on concrete, actionable topics: feature design, code architecture, UX improvements, what to build next",
      "alternatives": [],
      "rationale": "The system proved its value through actual use. Abstract meta-questions waste tokens and produce no actionable output.",
      "decidedAt": "2026-02-24T08:47:32.962Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_mp_scope_in",
      "title": "Multi-project support is now IN scope",
      "context": "Previously scoped out (Feb 22). Pat reversed this after experiencing the pain of opening Claude Code from tax-credit-calculators and having no HW tools available. The current single-project model doesn't work when Pat works across multiple projects.",
      "chosen": "Full multi-project support: project switcher, global vs project memory, auto-onboard new projects",
      "alternatives": [
        {
          "option": "Keep single-project",
          "tradeoff": "Simpler but forces Pat to only use HW from one directory"
        },
        {
          "option": "Manual project switching via config edit",
          "tradeoff": "Works but terrible UX, no auto-onboard"
        }
      ],
      "rationale": "Pat hit the real pain: opened Claude Code from a different project and had zero HW tools. Multi-project is a requirement, not a nice-to-have.",
      "decidedAt": "2026-02-24T17:00:00.000Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_c92d5e5a",
      "title": "Verification test decision (delete me)",
      "context": "Testing the decision recording feature during verification run.",
      "chosen": "Record and verify",
      "alternatives": [],
      "rationale": "Need to confirm the decision system works end-to-end.",
      "decidedAt": "2026-02-24T09:17:32.717Z",
      "decidedBy": "claude"
    },
    {
      "id": "d_d9b43d5b",
      "title": "Always write handoff before suggesting app restart",
      "context": "Pat noticed sessions losing context when Claude suggests restarting the app without saving state first",
      "chosen": "Mandatory hw_write_handoff() call before any restart suggestion, no exceptions",
      "alternatives": [],
      "rationale": "A restart kills the current session. Without a handoff, the next session starts blind. This rule prevents context loss.",
      "decidedAt": "2026-02-24T23:41:05.602Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_c0062113",
      "title": "Deliberation v2: one mandatory path + quick-insights",
      "context": "Self-audit of deliberation on guardrails found 5 structural failures. Deliberation panel (6 agents) converged on: one mandatory path for binding decisions, separate lightweight tool for flavor-testing.",
      "chosen": "One mandatory deliberation path (plan+coverage+conclude) with quality tags (consensus/tension/shifted). Separate hw_quick_insights for non-binding sanity checks. Balance notes optional. Auto-runner pauses at synthesis.",
      "alternatives": [
        {
          "option": "Two-tier mode (quick vs full deliberation)",
          "tradeoff": "Rejected: user must predict uncertainty before having data. Quick mode becomes a loophole to skip rigor."
        },
        {
          "option": "Keep balance notes required",
          "tradeoff": "Rejected: never changed mediation behavior in practice. Paperwork without signal."
        },
        {
          "option": "Keep binary coverage (addressed/not)",
          "tradeoff": "Rejected: enables checkbox theater. Agents can 'address' without real engagement."
        }
      ],
      "rationale": "Two-tier modes create prediction burden (user must guess stakes upfront). One path removes the choice. Quick-insights is clearly separate and non-binding. Quality tags replace binary coverage to catch checkbox theater and groupthink.",
      "decidedAt": "2026-02-25T01:05:33.241Z",
      "decidedBy": "both"
    },
    {
      "id": "d_4c882ae9",
      "title": "Buddy recap: hybrid rolling buffer + AI summary on clean exit",
      "context": "Need crash-safe session recap for buddy to display on next startup. Must survive X, Alt+F4, crashes.",
      "chosen": "Hybrid: rolling buffer continuously writes last ~10 activity items (crash-safe baseline). On clean exit, detached Node subprocess upgrades the raw buffer into an AI-generated summary. Buddy displays whichever exists -- polished if available, raw if crash.",
      "alternatives": [
        {
          "option": "Detached subprocess only",
          "tradeoff": "Nice summaries but no crash safety -- hard exits lose everything"
        },
        {
          "option": "Rolling buffer only",
          "tradeoff": "Crash-proof but raw activity data, not polished summaries"
        }
      ],
      "rationale": "Rolling buffer costs nothing (same pattern as activity.json). AI summary on clean exit gives a nicer experience when possible. Crash fallback to raw buffer means we never lose context. Best of both worlds.",
      "decidedAt": "2026-02-25T02:14:26.791Z",
      "decidedBy": "both"
    },
    {
      "id": "d_85462add",
      "title": "Build Cortex as standalone ACE replacement",
      "context": "Discussed adding Augment Context Engine MCP vs building our own. Pat wanted our own version tailored to our workflow.",
      "chosen": "Build Cortex: standalone MCP server at C:/Users/Patri/CascadeProjects/cortex/. Claude Haiku for file summarization, structured JSON index, keyword/concept search. No vector DB. 5 MCP tools: cortex_index, cortex_search, cortex_context, cortex_architecture, cortex_related.",
      "alternatives": [
        {
          "option": "Install Augment Context Engine MCP",
          "tradeoff": "Immediate 70% boost claim but not tailored to our workflow, dependency on external service"
        },
        {
          "option": "Install Perplexity MCP for research",
          "tradeoff": "Deep research but requires API key, monthly cost, not code-specific"
        }
      ],
      "rationale": "With agents we can build something more attuned to our needs. No vector DB infra complexity. Claude API handles the semantic understanding. Per-project index in .cortex-index/ directory.",
      "decidedAt": "2026-02-25T03:04:00.051Z",
      "decidedBy": "both"
    },
    {
      "id": "d_e5d0b81b",
      "title": "State storage: split files + atomic writes (B+), defer SQLite",
      "context": "state.json holds all tasks, decisions, questions, memories in one file. Concurrent write risk from MCP server, Discord listener. Deliberation with 4 agents.",
      "chosen": "Split state.json into tasks.json, decisions.json, questions.json, memories.json. Atomic writes via write-to-temp-then-rename with Windows NTFS retry loop. Backup copy before each write. Session-start hook .backup fallback. SQLite deferred to multi-project epic.",
      "alternatives": [
        {
          "option": "File locking only (Option A)",
          "tradeoff": "2 hours but doesn't fix truncation risk or reduce blast radius"
        },
        {
          "option": "SQLite migration (Option C)",
          "tradeoff": "Fixes everything but 2-3 days work, breaks file-watcher reactivity, MSVC compilation issues on Windows, premature given multi-project timeline"
        }
      ],
      "rationale": "Backendarch shifted from SQLite to B+ after: (1) multi-project epic is unplanned so SQLite timing is premature, (2) better-sqlite3 has MSVC native compilation issues on Windows, (3) split files are forward-compatible with eventual SQLite migration. Remaining no-ACID risk explicitly accepted.",
      "decidedAt": "2026-02-25T09:25:49.987Z",
      "decidedBy": "claude"
    },
    {
      "id": "d_53e538a6",
      "title": "Defer tauri-specta until Rust type refactor",
      "context": "Researched tauri-specta v2.0.0-rc.21 for type-safe IPC. All our Rust commands use serde_json::Value, so specta would just export JsonValue types -- zero benefit. The useTauriData hook pattern (dynamic string-based dispatch) is also incompatible with specta's static named functions. Still in RC with breaking changes between versions.",
      "chosen": "Defer tauri-specta adoption until we refactor Rust commands to use proper typed structs",
      "alternatives": [
        {
          "option": "Adopt now with Value types",
          "tradeoff": "Zero type safety benefit, adds RC dependency fragility for no gain"
        },
        {
          "option": "Adopt now and refactor all commands to typed structs",
          "tradeoff": "2-3 day effort, high risk of breaking running app, not the current priority"
        }
      ],
      "rationale": "Three blockers: (1) Value types everywhere means no actual type safety gain, (2) useTauriData hook pattern incompatible, (3) still RC with fragile dependency chain. When we do the Rust type refactor, adding specta at that point is nearly free.",
      "decidedAt": "2026-02-26T03:39:32.092Z",
      "decidedBy": "claude"
    },
    {
      "id": "d_8b644ccd",
      "title": "Defer Agent Teams, continue using subagents",
      "context": "Researched Claude Code Agent Teams (experimental). Requires CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1. Split-pane mode unsupported on Windows Terminal. Known issues: orphaned sessions, task status lag, no session resumption. Community reports UI crashes with 4+ agents.",
      "chosen": "Continue using subagents (Task tool) for parallel work. Defer Agent Teams until stable release.",
      "alternatives": [],
      "rationale": "Subagents are production-ready and cover our needs. Agent Teams adds inter-agent messaging and shared task lists, but instability on Windows and no split-pane support make it impractical. Will re-evaluate when it exits experimental.",
      "decidedAt": "2026-02-26T03:45:24.057Z",
      "decidedBy": "claude"
    },
    {
      "id": "d_814e624f",
      "title": "Watcher system: repurpose from per-task file copies to persistent crash-safety sentinel",
      "context": "The watcher system (hw_spawn_watcher, app_shutdown_copy type) was used for merging worktree Rust changes on app exit. Pat flagged watchers as more trouble than worth for that use case (terminal flashing, per-task overhead). Discussion revealed the real value: crash recovery. A detached process that survives app crashes can backup state, write crash markers, and enable graceful recovery.",
      "chosen": "Redesign watchers as a single persistent crash-safety sentinel spawned by buddy on startup. Hidden process (no console window), polls Tauri PID, runs recovery on crash/exit. Visual indicator on buddy shows sentinel health. Replaces dozens of per-task throwaway watchers with one always-on guardian.",
      "alternatives": [
        {
          "option": "Remove watchers entirely",
          "tradeoff": "Lose crash recovery capability -- no process survives a Tauri crash"
        },
        {
          "option": "Keep per-task watchers as-is",
          "tradeoff": "Terminal flashing, overhead, Pat already rejected this"
        },
        {
          "option": "Make buddy a separate executable",
          "tradeoff": "Architecturally cleaner but massive effort, separate build pipeline"
        }
      ],
      "rationale": "The sentinel survives crashes (detached process), is invisible to the user (windowsHide), and provides crash recovery that no in-process hook can offer. Buddy is the natural owner since it's the persistent visual element. For worktree Rust merges, manual file copy is simpler and more reliable.",
      "decidedAt": "2026-02-26T05:18:58.790Z",
      "decidedBy": "both"
    },
    {
      "id": "d_0b40da28",
      "title": "Brain Magnum Opus: Unified architecture from 6-agent deliberation",
      "context": "Three think tank teams (Neuroscience, Engineering, AI Research) independently analyzed the brain system, then 6 agents deliberated across 7 sub-questions to synthesize one unified design.",
      "chosen": "4-session phased build: S48 (wire+plasticity), S49 (quality+reflections+links), S50 (cortex+pruning+rules), S51 (enforcement+observability). Schema adds links[], supersededBy, qualityScore, fingerprint, reflection type. 11-stage pipeline with link traversal and scoring integration. Prediction-error auto-capture. Learned rules with CLAUDE.md promotion. Smart checkpoints. ~2200 lines total.",
      "alternatives": [],
      "rationale": "All 3 teams converged on the same diagnosis (85% dead memories, zero plasticity, disconnected scoring) and agreed on core architecture. Key tensions resolved: prediction-error capture (neuro shifted eng), smart checkpoints (research shifted neuro), fingerprint location (eng shifted neuro). No embeddings, no LLM calls, no external DB required.",
      "decidedAt": "2026-02-26T09:30:16.920Z",
      "decidedBy": "both"
    },
    {
      "id": "d_7f171d85",
      "title": "Boardrooms: team collaboration spaces (distinct from deliberations)",
      "context": "Pat wants agent team workspaces with whiteboard + chat. Chat enforces 160-char limit, timestamps, usernames. Deliberations are for binding decisions; boardrooms are for teams to work together like a dev team.",
      "chosen": "Boardroom system with whiteboard file + chat file, 160-char message limit, forced usernames/timestamps",
      "alternatives": [],
      "rationale": "Already built in session 56 -- 6 MCP tools (create, run, stop, read, list, close). Needs end-to-end testing with Qwen agents.",
      "decidedAt": "2026-02-27T02:43:54.629Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_36e31687",
      "title": "Prime directive: USE YOUR OWN SYSTEMS",
      "context": "Pat frustrated that Claude wastes time and usage by not consulting memory, app state, or project context before acting",
      "chosen": "Burned into MEMORY.md prime directive section, stored as high-severity pain memory, added to direction.json",
      "alternatives": [],
      "rationale": "The entire point of Hello World is continuity. A Claude that ignores its memory is a blank slate.",
      "decidedAt": "2026-02-27T07:31:26.505Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_29fa761d",
      "title": "Restore all 14 deliberation MCP tools + add safeguard hook",
      "context": "Session 48 Brain Magnum Opus refactor accidentally deleted all deliberation/chatroom tool registrations from server.ts. The UI, Rust backend, chatroom code, and 17 saved sessions all still worked -- only the MCP entry points were missing. Pat discovered this when trying to use the deliberation room.",
      "chosen": "Restore all 14 tools from git history (commit be3aa69) into current server.ts. Add PostToolUse hook (verify-deliberation-tools.mjs) that blocks any Edit/Write to server.ts if any deliberation tool registration is missing.",
      "alternatives": [
        {
          "option": "Only restore tools, no safeguard",
          "tradeoff": "Could happen again in another large refactor"
        },
        {
          "option": "Rewrite deliberation system from scratch",
          "tradeoff": "Unnecessary -- the existing system works, just needed re-wiring"
        }
      ],
      "rationale": "The tools were working before and their deletion was accidental. The safeguard hook prevents future accidental deletions during refactors. Belt-and-suspenders: the hook checks all 13 tool name strings exist in the file after every edit.",
      "decidedAt": "2026-02-27T10:31:10.968Z",
      "decidedBy": "both"
    },
    {
      "id": "d_1b6a3600",
      "title": "Multi-project: hub model, not project-scoped switching",
      "context": "The MP epic (4 sub-tasks) assumed project-scoped context: separate memories per project, project switcher UX, auto-onboard, global vs local memory split. Pat questioned whether we should reset/switch at all. HW already works from any directory via global MCP. The brain's value comes from cross-project lessons, not isolation.",
      "chosen": "Hub model: one brain, one memory pool, no project switching. Tasks/memories get a project tag for filtering, not scoping. App respects launch directory (CWD bug) but doesn't partition state. The MP epic's 4 sub-tasks are replaced by a simple tag+filter approach.",
      "alternatives": [
        {
          "option": "Project-scoped switching (original MP epic)",
          "tradeoff": "Isolates context per project but fragments brain knowledge, complex UX, 4 sub-tasks of work"
        },
        {
          "option": "Hybrid: global brain + project-scoped tasks",
          "tradeoff": "Middle ground but still needs switcher UX and adds complexity for marginal benefit"
        }
      ],
      "rationale": "Simpler architecture, preserves cross-project learning, matches how IDEs work. Scoping memories per project would fragment the brain's most valuable asset: lessons that transfer across codebases. The project switcher UX was solving a problem that doesn't exist if there's nothing to switch.",
      "decidedAt": "2026-02-27T13:45:47.095Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_8d6d0809",
      "title": "Remove approvals and questions systems -- never used, all handled in terminal",
      "context": "Pat finds the approvals gate system (hw_check_approval, hw_list_approvals, hw_resolve_approval) and the questions system (hw_add_question, hw_answer_question) annoying and never used. All of these interactions happen naturally in conversation. Dedicated systems and app views are overhead.",
      "chosen": "Remove both systems: approvals (MCP tools, app view, Discord integration) and questions (MCP tools, app view). Approval gates in CLAUDE.md become simple \"ask Pat in chat\" rules. Questions are just conversation.",
      "alternatives": [],
      "rationale": "Never used. Terminal conversation handles both. Removing reduces tool clutter, simplifies MCP server, removes unused app views.",
      "decidedAt": "2026-02-27T13:59:24.321Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_13cd73d2",
      "title": "Hub model replaces multi-project scoping",
      "context": "Pat rethought multi-project support. Instead of project-scoped context switching, HW should be a hub that works on any project like a regular IDE -- one brain, one set of memories, tasks visible across projects.",
      "chosen": "Hub model -- HW works on any project without reset/switch, obsoleting the MP epic's 4 sub-tasks",
      "alternatives": [],
      "rationale": "Simpler architecture, no context switching overhead, one brain works everywhere",
      "decidedAt": "2026-02-27T14:25:39.081Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_409c946f",
      "title": "Knowledge intake: two-phase pipeline with manual-first trial",
      "context": "Research pipeline was 100% manual. Deliberated with 5 agents (Product Mgr, Backend Arch, Cost Analyst, DevOps, Pragmatist) over 2 structured rounds. Key tension: session-start vs weekly scheduler vs on-demand. Pragmatist's \"automate what works\" principle shifted 4/5 agents toward manual trial first.",
      "chosen": "Phase 1: manual /scan writing to knowledge-queue.json staging file, zero-LLM scan, existing quality gates, max 5 memories/cycle. Phase 2: weekly Task Scheduler after 3-week trial IF 3+ useful memories stored and retrieved. Kill switch if no value proven.",
      "alternatives": [
        {
          "option": "Session-start hook triggers scan every session",
          "tradeoff": "Burns tokens on every session even when nothing changed upstream. 20 sessions/week = worse than weekly batch."
        },
        {
          "option": "Pure on-demand /scan with no automation path",
          "tradeoff": "Zero infrastructure cost but knowledge rots silently when Pat forgets to scan."
        },
        {
          "option": "Daily Task Scheduler from day one",
          "tradeoff": "Better CVE timeliness but automates an unproven pipeline. No evidence intake delivers value yet."
        }
      ],
      "rationale": "Every agent agreed on zero-LLM scanning and tight source list. The room shifted from automation-first to prove-value-first after Pragmatist challenged whether manual intake even works well enough to automate. Cost Analyst's math showed session-start triggers would cost more than weekly batches. DevOps's staging file pattern provides observability and rollback.",
      "decidedAt": "2026-02-27T15:03:53.311Z",
      "decidedBy": "claude"
    },
    {
      "id": "d_620bcfd7",
      "title": "Knowledge intake: expand source list beyond dependencies",
      "context": "Deliberation d_409c946f consensus was narrow sources (Tauri, React, Anthropic only). Pat overrides: Claude should track AI news and coding trends broadly, not just its own stack. The project vision is a well-informed autonomous developer. Pipeline mechanics stay the same (manual /scan, staging queue, quality gates, max 5/cycle).",
      "chosen": "Expand knowledge intake sources to include: (1) dependency docs (Tauri, React, Anthropic), (2) AI news and developments, (3) latest coding news, tools, and frameworks. All other pipeline decisions from d_409c946f remain unchanged.",
      "alternatives": [
        {
          "option": "Keep narrow source list (dependencies only)",
          "tradeoff": "Lower noise but Claude stays ignorant of industry trends"
        }
      ],
      "rationale": "Pat's direction -- the project vision is broader than dependency tracking. Claude should be industry-aware.",
      "decidedAt": "2026-02-27T15:59:23.508Z",
      "decidedBy": "pat"
    },
    {
      "id": "d_c7206dab",
      "title": "Three brain capabilities: session tags, notify gate, procedural memory",
      "context": "Deliberation with 4 agents (Backend Arch, Product Mgr, Pragmatist, Cost Analyst) over 2 rounds. Inspired by research scan: Aurora outcome tags, U-Mem uncertainty cascade, Hermes skill documents. Key constraint: LangChain finding that generalization prompting is harder than infrastructure.",
      "chosen": "Build order: (1) Session outcome tagging -- infer from task status + activity patterns at hw_end_session, zero cost, chips in SessionsView. (2) Notify gate -- require hw_retrieve_memories before hw_notify, don't escalate if memories cover the topic. (3) Procedural memory -- add 'skill' as proper MemoryType enum value, defer build until session tags reveal patterns. All zero API cost.",
      "alternatives": [
        {
          "option": "Don't build anything, run 10 sessions first (Pragmatist R1)",
          "tradeoff": "Loses free data collection opportunity. Session tags ARE the validation step."
        },
        {
          "option": "Separate skills/ file system (Backend Arch)",
          "tradeoff": "160 lines of new infrastructure for unproven feature. Maintenance tax."
        },
        {
          "option": "Prefix convention on fact type (Pragmatist R1)",
          "tradeoff": "Won't surface in tag-based retrieval. Half-measure rejected by all 4."
        }
      ],
      "rationale": "4/4 on session tags and notify gate. Skills split but consensus on proper implementation (real type, not prefix hack). Pragmatist shifted on tags (near-zero cost justified). Backend Arch shifted on uncertainty timing (real-time gate beats post-session). ~150 lines total new code.",
      "decidedAt": "2026-02-27T16:59:10.542Z",
      "decidedBy": "claude"
    }
  ]
}